{Chapter}
{Title}The Module System and the Module Compiler{/Title}
{Para}
{Sect1}
{Title}Introduction and Terminology{/Title}
{Para}
It is good practice to divide a large program into smaller units that
can be independently understood.  Such units are called modules.
RScheme has full support for modules.
{Para}
Traditionally, there are two different purposes of modules.  The first
and least interesting purpose is to function as a unit of
compilation.  Early versions of Fortran already supported separate
compilation of this type of module.  The second and most interesting
purpose of a module is to encapsulate related data and functions with
a restricted view from the outside.  Typically, modules are used to
hide implementation details of some abstract data type that can only
be used by other modules (called the client modules) through a
well-defined set of functions called the interface of the abstract
data type.
{Para}
In RScheme a module is both a unit of separate compilation and a unit
of encapsulation.  Currently, only the off-line compiler (or module compiler)
{UserInput/rsc/
can create a module.
{Para}
You may think of a module as an augmented top-level environment
mapping names to variables, macros, or special forms (collectively
called {FirstTerm Role="defn"}bindings{/FirstTerm}).  Bindings are not first-class objects so you cannot
manipulate them the way you manipulate other RScheme objects such as
numbers and strings.  In addition to the collection of bindings, a
module contains information about which bindings are visible from the
outside (exported) and which bindings are purely local to the module.
Finally, a module contains information about what other modules are
needed by the module (called the imported modules).
{Para}
When a module M imports a module N, the top-level environment of M is
augmented with the name-to-binding mappings of N that are exported.
RScheme provides functionality to give different names of
these bindings from those used by N, so that both M and N share the
same bindings, but under different names.  This renaming is useful
when you need to avoid name clashes between modules. 
{Para}
The collection of modules together with the imports relation 
in a program form a directed acyclic graph.
In other words, it is not possible for modules to be mutually
imported. 
{Para}
{Sect1}
{Title}Organization of a Module{/Title}
{Para}
A module is organized as a collection of source files (extension 
{UserInput/.scm/)
and a module control file (extension {UserInput/.mcf/).  The source files are
logically concatenated by the module compiler so that there is no
encapsulation between different source files in a module. The module
control file indicates the order of the concatenation of the source
files.  This order may be important, since a binding, such as a macro,
may be created in
one file and used in another.{Footnote}{Para}Although normal variables, which
are used to contain function and data values, may occur in 
any order{/Footnote}
{Para}
The source files are ordinary RScheme files that can be understood by
the interactive on-line compiler.  Typically, you would use the
procedure load to add the contents of these source files to your
interactive RScheme environement during the development phase.
Loading the source files does not involve the module compiler at all.
Instead the on-line interactive compiler translates the source to some
interal form (e.g. bytecodes) that can be executed relatively fast.
The on-line interactive compiler is faster than the off-line module
compiler, so that in a phase of frequent modifications to source code
you can rapidly test new versions of your code.  However, the off-line
compiler produced much faster executable code, so that when you are
reasonably sure that your program is bug-free, you typically use the
off-line module compiler on your code in order to produce fast
executable code. 
{Para}
{Sect1}
{Title}Compilation and its Semantics{/Title}
{Para}
We have already used the concept of loading above.  The compiler
introduces some other concepts that need to be understood in order for
the compilation process to make sense.  
{Para}
Compiling a module involves translating the source code in the source
files to a different format that is no longer in the form of source
code.  The off-line module compiler puts the result of this
translation in a file called the module image file (extension
{UserInput/.mif/).
{Para}
The module index ({UserInput/.mx/) file contains various names that are
important to the linker, in particular module entry points and a list
of dynamically linked (extension {UserInput/.so/) files.  The module index
file and the module image file are both logically part of the "object
code" generated by the compiler and should always be manipulated
together.  In particular, they should both be installed in the same
directory.
{Para}
The contents of this module image file can then be added to your
interactive RScheme enviroment in a way similar to loading described
above.  Conceptually, this process is divided into two steps, the link
step and the import step.  Linking simply takes the module image file and
incorporates it into the interactive RScheme enviroment without
making any connection between the linked module and the current module.
Linking is just the extension, at runtime, of the set of modules present
in the heap; the system starts out with a set of default modules already
present and linked.  Importing, on the other hand, simply binds 
names in the
current module to the exported variables of the imported module.
{Para}
In the interactive RScheme environment, you typically use the command
{UserInput},(use {Parameter/module/){/UserInput} to import a module, 
where module is the name (in the
form of a symbol) of a module.  The module image file is formed
by adding a {UserInput/.mif/ extension to the string form of the symbol.
Recall that forms that start with a
comma are conceptually executed outside the interactive environment.
The command {UserInput/,(use foo)/ will first check whether the module
{UserInput/foo/ has
already been linked.  If not, then it tries to find the module image
file and link it.  If it cannot find the module image file, an error
message is given.  If the module is already linked, or if the module
file was found and successfully linked, the {UserInput/,(use foo)/ command will
procede to the population step and add the exported top-level bindings
to the interactive RScheme environment. 
{Para}
Conceptually, the meaning of the linking step is similar to the
meaning of loading source.  It is during the linking step that
top-level forms in the source code (i.e. the {Filename}.scm{/Filename}
files that were
mentioned during compilation) are conceptually evaluated in order.  We
say ``conceptually'' because the compiler is free to replace this
top-level evaluation by something more efficient provided that the
effect in the interactive RScheme environment is the same.  The most
important such transformation that the compiler does is to convert
each lambda expression to machine code that has the same effect as the
lambda expression itself, except that it is much faster.

&ref.use;
&ref.rsc;
<!-- these need to be fixed
&ref.open;
&ref.files;
&ref.export;
-->